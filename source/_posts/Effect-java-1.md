---
title: Effect java(1)
date: 2018-01-08 16:58:44
tags: java
categories: java
---

1. 创建和销毁对象。
    1.  考虑用静态工厂方法代替构造器。
        - 构造器没有名称
        - 不用每次都创建对象
    2.  遇到多个构造器参数时考虑用构建器
        - 总的来说就是因为重叠构造器（多个构造器初始化一些缺省参数）写的太繁琐， JAVABEAN(不够安全，可能不一致，而且使得类必须可变)不够给力，而诞生的一种中和方法。大致思想是利用两个类（内层类和外层类），内层类控制类构建的初始化和SETTER，完成后调用内层类的build方法将内层类的域变量传递给外层类，而外层类的域变量皆是private final，保证了单一不可变类，安全……
    3.  用私有构造器或者枚举类型强化Singleton属性
        - 在类中声明一个公有final域并且初始化为一个类实例（public static final OBJ instance = new OBJ();) 可以通过反射机制破坏~
        - 公有成员是个静态工厂方法， 序列化会有问题
        - 编写一个包含单个元素的枚举类型。 既好序列化，也安全。
    4.  通过私有构造器强化不可实例化的能力
        - 用于一些工具类，不希望被实例。
        - 企图通过将类做成抽象类来强制该类不可被实例化~ 非常错误， 因为该类可以被子类化，子类可以被实例，相当于误导使用者
        - 让类包含私有构造器， 就不能被实例化了~ 有副作用， 它使得类不能被子类化
    5.  避免创建不必要的对象
        - 一般来说， 最好能重用对象 而不是在每次需要的时候就创建一个相同功能的新对象。
        - 不可变类重用， String s = new String('zzgo') // nonononono
        - 可变类 ， 但是我们的需求是生成后不改变， 那么我们可以static final 来控制实例化一次。
        - 注意自动装箱的情况~ Long sum = 0L , sum += 1. 这样会产生两个对象， 那为何不 long sum = 0L, sum += 1呢？ 优先使用基本类型而不是装箱基本类型， 要当心无意识的自动装箱。
        - 不要错误地认为“创建对象的代价非常昂贵， 我们应该要尽可能地避免创建对象”。 相反， 小对象的构造器只做很少的显示工作，构建和回收都很廉价。 如果能通过创建附加的对象提升程序的可读性、简洁性 ， WHY NOT?
        - 必要时如果没能实施保护性拷贝， 将会导致潜在的错误和安全漏洞； 而不必要地创建对象只会影响程序的风格和性能。
    6.  消除过期的对象引用
        - 栈（先增加后减少） size外的引用即是过期。
        - 如果一个对象引用被无意识地保留起来了，那么，垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象。
        - 清空对象引用应该是一种例外， 而不是一种规范行为。
        - 一般而言， 只要类是自己管理内存， 程序员就应该警惕内存泄漏问题。一旦元素被释放，则该元素中包含的任何对象应用都应该被清空。
        - 其他内存泄漏来源还有：缓存、监听器和其他回调 （不是很懂O O.）
    7.  避免使用终结方法
        - JVM会自己回收， 不要你多余操作
        - 有时候自己终结 反而会导致系统回收变慢（PYTHON 手动CLOSE资源反而有点BUG！ 用WITH）
2. 对于所有对象都通用的方法。
    8.  覆盖equals时请遵守通用约定
        - 一种实现高质量equals方法的诀窍 1.使用==操作符检查“参数是否为这个对象的引用”。 2.使用instanceof操作符检查“参数是否为正确的类型”。 3.把参数转换成正确的类型。 4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。
        - 当你编写完成了equals方法之后， 应该问自己：它是否是对称的、传递的、一致的（多次调用结果不变）
        - 覆盖equals时总要覆盖hashCode
        - 不要企图让equals方法过于智能。
        - 不要将equals声明中的Object对象替换为其他的类型。 （相当于不是重载 而是重写， 会出问题）？
    9.  覆盖equals时总要覆盖hashCode
        - hashmap等容器 在比较时首先比较hash 再比较equal， 如果不覆盖hashCode 会出问题。
    10. 始终要覆盖toString
    11. 谨慎地覆盖clone
        - 自己从未用过 甚至不知道是神马
        - 反正不覆盖就是了呗
    12. 考虑实现Comparable接口
        - 实现了Comparable接口后， 对象数组排序很简单， Arrays.sort(a);
        - 要放进TreeSet这种维持大小的容器， 一定要实现comparable
        - compareTo方法的通用约定与equals方法很相似
        - 返回 符号， - 表示 当前这个是小的， 0 一样大 ， + 表示大。 所以有两种方法， 第一、 手比较 返回符号， 第二、 直接 返回 比较结果 （速度快 但是可能溢出）
