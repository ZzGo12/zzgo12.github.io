---
title: Effect-java-2
date: 2018-01-30 14:54:30
tags: java
categories: java
---


1. 类和接口。
    1.  使类和成员的可访问性最小化
        - 尽可能地使每个类或者成员不被外界访问。
        - 除了公有静态final域的特殊情形之外（常量），公有类都不应该包含公有域
        - 确保公有静态final域所引用的对象都是不可变的。
    2.  在公有类中使用访问方法而非公有域
        - 总之，公有类永远都不应该暴露可变的域。
    3.  使可变性最小化
        - 不可变类比可变类更加易于设计，实现和使用
        - 优点：线程安全， 易于共享
        - 缺点：开销大， 一旦需要改变， 就要重NEW 一个类
        - 使类成为不可变，遵循下面五条规则： 不要提供任何会修改对象状态的方法、 保证类不会被扩展、 使所有的域都是final的、 使所有的域都成为私有的、 确保对于任何可变组件的互斥访问。
    4.  复合优先于继承
        - 继承打破了封装性， 当超类发生变化， 子类会受到影响
        - 可以考虑 在新的类中增加一个私有域， 它引用现有类的一个实例
        - 只有当子类真正是超类的子类型时， 才适合用继承。
    5.  避免创建不必要的对象
        - 一般来说， 最好能重用对象 而不是在每次需要的时候就创建一个相同功能的新对象。
        - 不可变类重用， String s = new String('zzgo') // nonononono
        - 可变类 ， 但是我们的需求是生成后不改变， 那么我们可以static final 来控制实例化一次。
        - 注意自动装箱的情况~ Long sum = 0L , sum += 1. 这样会产生两个对象， 那为何不 long sum = 0L, sum += 1呢？ 优先使用基本类型而不是装箱基本类型， 要当心无意识的自动装箱。
        - 不要错误地认为“创建对象的代价非常昂贵， 我们应该要尽可能地避免创建对象”。 相反， 小对象的构造器只做很少的显示工作，构建和回收都很廉价。 如果能通过创建附加的对象提升程序的可读性、简洁性 ， WHY NOT?
        - 必要时如果没能实施保护性拷贝， 将会导致潜在的错误和安全漏洞； 而不必要地创建对象只会影响程序的风格和性能。
    6.  消除过期的对象引用
        - 栈（先增加后减少） size外的引用即是过期。
        - 如果一个对象引用被无意识地保留起来了，那么，垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象。
        - 清空对象引用应该是一种例外， 而不是一种规范行为。
        - 一般而言， 只要类是自己管理内存， 程序员就应该警惕内存泄漏问题。一旦元素被释放，则该元素中包含的任何对象应用都应该被清空。
        - 其他内存泄漏来源还有：缓存、监听器和其他回调 （不是很懂O O.）
    7.  避免使用终结方法
        - JVM会自己回收， 不要你多余操作
        - 有时候自己终结 反而会导致系统回收变慢（PYTHON 手动CLOSE资源反而有点BUG！ 用WITH）
2. 对于所有对象都通用的方法。
    8.  覆盖equals时请遵守通用约定
        - 一种实现高质量equals方法的诀窍 1.使用==操作符检查“参数是否为这个对象的引用”。 2.使用instanceof操作符检查“参数是否为正确的类型”。 3.把参数转换成正确的类型。 4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。
        - 当你编写完成了equals方法之后， 应该问自己：它是否是对称的、传递的、一致的（多次调用结果不变）
        - 覆盖equals时总要覆盖hashCode
        - 不要企图让equals方法过于智能。
        - 不要将equals声明中的Object对象替换为其他的类型。 （相当于不是重载 而是重写， 会出问题）？
    9.  覆盖equals时总要覆盖hashCode
        - hashmap等容器 在比较时首先比较hash 再比较equal， 如果不覆盖hashCode 会出问题。
    10. 始终要覆盖toString
    11. 谨慎地覆盖clone
        - 自己从未用过 甚至不知道是神马
        - 反正不覆盖就是了呗
    12. 考虑实现Comparable接口
        - 实现了Comparable接口后， 对象数组排序很简单， Arrays.sort(a);
        - 要放进TreeSet这种维持大小的容器， 一定要实现comparable
        - compareTo方法的通用约定与equals方法很相似
        - 返回 符号， - 表示 当前这个是小的， 0 一样大 ， + 表示大。 所以有两种方法， 第一、 手比较 返回符号， 第二、 直接 返回 比较结果 （速度快 但是可能溢出）
